# 1. BTC-密码学

比特币（BTC，Bitcoin）被称为加密货币（cryptocurrency），实际上是不加密的，信息都是公开的。

比特币中主要用到了密码学中的两个功能：

- 哈希
- 签名

## 哈希

密码学中的哈希函数称为cryptographic hash function。有两个重要的性质：

### collision resistance

又叫做collision free

 collision（哈希碰撞）：两个不同的输入算出来的hash值是相等的，哈希碰撞是很常见的，也是不可避免的。（输入空间远远大于输出空间） 

collision resistance：没有高效的方法人为地制造哈希碰撞。（蛮力求解可以brute force，但是对于较大的输出空间来说就很难了）  

这个性质可以用对message求digest，用来检测是否对message篡改。（也就是没有什么高效的方法使得在修改了message后得到的digest和原先的相同）。

有的哈希函数经过时间的检验，没有找到可以人为地制造哈希碰撞的方法，但是有的哈希函数就可以人为制造哈希碰撞，比如MD5

### hiding

哈希函数的计算过程是单向的，不可逆的。 

当输入空间足够大，且输入分部比较均匀（各种取值的可能性差不多时）暴力求解也难以破解。



这两个性质结合在一起可以用来实现 digital commitment（digital equivalent of  a sealed envelop）

例如：预测股票时，可以向外界公布有关股票的哈希值，当结果出来后，再公布预测值，通过哈希函数来检验由预测值能够得到已经公布的哈希值。

当输入的空间不是足够大时，可以在输入后面拼接一个随机数，然后整个取哈希。



除了密码学中的这两个性质之外，比特币中用到的哈希函数还需要第三个性质：

### puzzle friendly

因为通过输入值很难直接算出该输入值的哈希函数的输出值 。

挖矿实际上就是找一个随机数 nonce，这个数和区块的块头中其他信息合在一起作为输入，得出一个哈希值，这个哈希值要小于等于某个指定目标阈值target 。

区块链是一个个区块组成的链表，每一个区块有一个块头（block header），其中有很多的域，其中的一个域是可以设置的随机数nonce。挖矿的过程就是尝试各种随机数，使得整个block header取哈希之后落在指定的范围之内 。

该性质是指挖矿的过程没有捷径，只有不断的尝试各种nonce，才能找到符合要求的解。所以这个过程才可以作为工作量证明（proof of work）。

虽然挖矿的过程需要大量工作量，才能找到一个符合要求的nonce，但是如果有人找到了nonce并发布出去后，其他人要验证是否符合要求是非常容易的（只需要计算一次哈希值）。difficult to solve, but easy to verify。



比特币中用的哈希函数是SHA-256（secure hash algorithm），这三个性质都是满足的 。

## 签名

### symmetric encryption algorithm

最早的加密体系是对称的（symmetric encryption algorithm）。两个人之间要进行通讯，但是这个通讯的网络是有可能被窃听的，于是事先商量好一个密钥，用密钥把信息加密之后发出，接受者收到之后再用这个密钥解密，因为这个加密和解密用的是同一个密钥，所以这个叫做对称的加密体系。它这个前提是假设有某种安全的渠道，能够把这个密钥分发给通讯的双方。这个是对称加密体系的一个弱点：密钥的分发不是很方便。

### asymmetric encryption algorithm

为了解决这个问题。非对称加密体系（asymmetric encryption algorithm）就提出来。用一对密钥，一个公钥和一个私钥。

加密用的是公钥，解密用的是私钥。加密和解密用的都是接收方的公钥和私钥。

公钥是不用保密的，可以告诉所有的人。私钥是要保密的，只要保存在本地就行了，不用传给对方，这就解决了对称加密体系当中密钥分发不方便的问题。

比特币是去中心化的，每个用户自己决定开户，开户的过程只需要在本地创建一个公私钥对（public key, private key），在比特币中代表了一个账户。公钥就相当于你的银行账号，别人要给你转账，只要知道你的公钥就行了。这个私药相当于你的账户密码，知道这个私钥，就可以把这个账户上的钱转走。
比特币在发布交易的时候，要用自己的私钥对这个交易签名。接收者用发起交易者的公钥去验证这个签名的正确性。签名用的是私钥，验证签名公钥，仍然都是同一个人的。
这里假设产生公私钥对的时候，是有一个好的随机源（a good source of randomness），生成公私钥对的过程显然是随机的。
比特币中不光是生成公私钥的时候，要有好的随机源，之后每一次签名的时候也要有好的随机源，只要有一次签名的时候用的随机源不好的话，就有可能泄露私钥。

# 2. BTC-数据结构

## 哈希指针

普通的指针存储的是某个结构体在内存中的地址，哈希指针除了要存这个地址之外，还要保存这个结构体的哈希值，一般是用 H 表示一个哈希指针。依据哈希指针，不光可以找到这个结构体的位置，同时还能够检测出这个结构体的内容有没有被篡改（因为保存了他的哈希值）。

比特币中一个最基本的数据结构就是区块链。区块链就是区块组成的链表，与普通链表的一个区别就是用哈希指针代替了普通的指针。（Block  chain is a linked list using hash pointeer）。
![](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221010211734734.png)

最前面的区块是系统中产生的第一个区块，叫做创世纪块（Genesis block），最后的区块是最近产生的区块（most recent block）。每个区块都包含指向前一个区块的哈希指针，最后的区块也有一个 hash point 保存在系统里。取哈希的时候是把整个区块的内容合在一起取哈希，包括里面的 hash point ，通过这样的数据结构可以实现 temple evident log（只要记住一个区块的哈希值，就可以检测出对区块链中任何部位的修改。不论是在哪个部位做了改动，最后都会导致保存的区块的哈希值会发生变化）。

就普通链表的话，可以改变其中一个原素，对链表中的其他元素是没有影响的。而区块链是牵一发而动全身，改变前面的任何一个区块都会引发多米诺骨牌效应，后面所有的区块都得跟着改。有这个性质之后，比特币中的节点就不一定要保存整条区块链的内容，要用到以前的区块时可以再问系统中的其他节点去要这个区块。可以通过计算给定区块的哈希值来和后面的区块中保存的指向它的哈希指针中的哈希值作比较，来判断是否相等，从而验证给定区块的正确性。

## Merkle tree

Merkle tree 和 binary tree 的区别：一个区别就是用哈希指针代替了普通的指针

![](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221001223920740.png)

最下面的一层是数据块（Data blocks），上面的节点都是哈希指针。

最下层相邻的两个数据块的哈希值拼在一起，再取一个哈希存在上层节点，依次向上，最后得到根节点（root hash）。只要记住最上面对根节点取哈希的哈希值，那么整棵树都保护了，哪个地方进行了修改，都能检测的到。

比特币当中，各个区块之间用哈希指针连接在一起的，每个区块所包含的交易组织成一个 Merkle tree 的形式。这种 Merkle tree 最下层的每个数据块实际上是一个交易（Transaction）。



### proof of membership

或者是proof of inclusion，即证明存在性，Merkle tree可以用来证明交易的存在性。

每个区块分为两部分：块头（block header ）和块身（block header）。

在 block header 保存着 Merkle tree 的根哈希值，但是 block header 里没有交易的具体内容，只有一个根哈希值，block body 里面是有交易的列表的。 

比特币中的节点分为两类，一类是全节点，还有一类是轻节点。

- 全节点是保存整个区块的内容（block header 和 block body）它有交易的具体信息。

- 但是轻节点（比如手机上的比特币钱包的应用就属于轻节点）只保存一个 block header 

此时如果需要向一个轻节点证明某个交易是写入到区块链中的。就要用到 Merkle proof 找到这个交易所在的位置。从某个交易往上一直到根节点这条路径就是 Merkle proof 。Merkle tree 一个用途就是提供 Merkle proof。
![](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221010232231398.png)
最上面这一行是一个小型的区块链，下面的是其中的一个区块的 Merkle tree。

最下面这一行是 Merkle tree 包含的交易，假设某个轻节点想知道图中标成黄色的这个交易是不是被包含在了这棵Merkle tree 里面，这个轻节点没有保存交易列表，没有这棵 Merkle tree 的具体内容，只有一个根哈希值。

这个轻节点向某个全节点发出请求，请求一个能够证明这个黄色的交易被包含在这颗 Merkle tree 里面的 Merkle proof。 全节点收到这个请求之后，只要把图中标为红色的这三个哈希值发给这个轻节点就行了（全节点在 Merkle proof 里提供的这几个哈希值，就是从这个黄色的交易所在的叶节点的位置到树根的路径上用到的这些哈希）。有了这些哈希值和交易的哈希值之后，轻节点在本地可以依次向上计算出整棵树的根哈希值。

轻节点把这个根哈希值跟 block head 中的哈希值比较一下，就能知道这个黄色的交易是不是在这棵 Merkle tree 里。

对于轻节点来说，发给这样的一个 Merkle proof 要验证它时间和空间的复杂度：如果底下这一层如果一共有 N 个交易的话，那么 Merkle proof的复杂度是对数级别的： $O(\log (n))$ ，这个是比较高效的。

### proof of non membership

证明不存在性。

有一个最简单的证明方法，把整棵树传给这个轻节点。轻节点收到之后，验证一下这个树的构造都是对的，这个每一层用到的哈希值都是正确的说明树里只有这些叶节点没有别的。那找的这个交易不在里面就证明了 proof of non membership 。这个复杂度是是线性的，效率较低。

如果我们对这些叶子节点的排列顺序做一些要求，比如说按照这个交易的哈希值排序，对于要查的那个交易，先算出一个哈希，然后看看如果它在里面的话应该是在哪个位置，然后把它假设的位置的左右两个交易向上计算哈希值，最后根节点算出来的哈希值如果正确，说明什么说明这两个节点在原来的 Merkle tree 里面确实是相邻的节点，所以要找的交易是不存在的。这个复杂度也是$O(\log (n))$ 的，代价是要排个序。

这种排好序的叫做 Sorted Merkle。比特币当中没有用到这种排好序的Merkle tree，因为比特币当中并不需要做这种不存在证明，所以比特币中的 Merkle tree 不要求排序。



其实只要这个数据结构是无环的，都可以用哈希指针来代替普通的指针。如果是有环的话，用普通指针，这个其实是一个很常见的循环链表，就是完全合法的。但如果这是哈希指针的话就变成循环依赖了。（哈希指针要依赖于前一个区块的内容）



# 3. BTC-共识协议



一个去中心化的货币要解决两个问题：

- 一是数字的数字货币的发行，谁有权利决定发行数字货币，该发行多少？这个在比特币系统中是由挖矿决定。
- 二是怎么验证交易的有效性？怎么防止 double spending attack？



需要维护一个由所有的用户共同维护的区块链。



## 防止 double spending attack

（花两次攻击，双花攻击）

使用哈希指针将币的每次交易串联起来，构成了一个小型的区块链。不同于之前连接各个区块的哈希指针，此处的哈希指针是指向前面的某个交易，用来说明币的来源。

![image-20221010211734734](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221011094004893.png)

比特币系统中每个交易都包含了输入和输出两部分：

- 输入部分要说明发起人的公钥以及发起人用私钥的签名。

  通过发起人的公钥，可以通过哈希指针从这个区块往币的来源回溯一下，检查币的来源，以此来证明这个钱不是凭空捏造的，是有记录的。如果发现币在这个交易之前已经被花出去了，就说明这个交易是不合法的，就不会写入到区块链里，防止double spending attack。

  通过私钥的签名可以证明交易确实由发起人发起的。

- 输出部分要给出收款人的公钥的哈希。

  公钥的哈希就类似于卡的地址。

> 铸币交易：能够凭空发行货币

在比特币系统当中，验证的过程是通过执行脚本（bitcoin script）来实现的。每个交易的输入和输出各是一段脚本，需要验证合法性时，把当前这个交易的输入脚本和前面提供币的来源的交易的输出脚本拼在一起，然后验证能否执行，如果可以执行的话才说明是合法的。

实际系统当中每个区块可以包括很多个交易，这些交易就组织成 merkle tree。



## 区块链中包含的内容

每个区块分成块头（block header）和块身（block body）两部分。

block header 里包含的是这个区块的一些宏观的信息:

- version（比特币版本的协议）

- hash of previous block header

- merkle root hash：能够保证 block body 里所包含的 transaction list 是没有被篡改的。

- target：挖矿的难度目标阈值
- nonce：随机数 

block body中只包含了交易的列表：

- transaction list



挖矿需要求的puzzle：$H \text { (block header) } \leqslant \text { target }$

block header 里存的是目标阈值的一个编码（nBits）

哈希前一个区块的只算的是block header的哈希值：

![image-20221010232231398](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221011101958018.png)



实际当中系统中的节点分为全节点 （full node）和轻节点（light node）：

- 全节点：保存区块链的所有信息，然后验证每一个交易。所以全节点也叫做 fully validating node
- 轻节点：只保存这个 block header 的信息，有时候也叫 light weight node。一般来说，轻节点没有存以前的交易信息，没有办法独立验证交易的合法性。轻节点没有参与区块链的构造和维护，它只是利用了区块链的一些信息做一些查询之类的。

## Consensus in BitCoin 

区块链是个去中心化的账本，用分布式系统的术语来说，账本的内容要取得分布式的共识（distributed consensus）。

> 分布式共识一个比较简单的例子就是分布式的哈希表。比如系统里有很多台机器共同维护一个全局的哈希表，这里需要取得共识的内容就是哈希表中包含了的 key value pair。

> 分布式共识有很多的不可能结论（Impossibility result）：
> - FLP impossibility result：对于一个异步系统（asynchronist system），网络传输时延没有上限，即使只有一个成员是有问题的（ fault）， 那么也不可能取得共识。
> - CAP theorem：C（consistency）、A （availability）、P (partition tolerance）。任何一个分布式系统，这三个性质当中最多只能满足两个，不可能三个性质都满足。 
> - ……

> 分布是共识的一个比较著名的协议：Paxos。这个协议能够保证一致性。如果这个协议达成了共识，这个共识一定是一致的。 但是某些情况下，Paxos协议有可能一直没有办法达成共识，这种可能性在实际系统当中是比较小的。但是客观存在的。



比特币中将区块写入区块链中的权力，是根据投票产生的。

> 任何基于投票的方案，首先要确定谁有投票权（membership） 。如果这个区块链它的 membership 是有严格定义的，比如有的叫联盟链（hypeliger fabric），只有某些符合条件的大公司才能加入。那么这种情况下基于投票的方案是可行的。

> sybil attack（女巫攻击）：恶意的节点不停的产生账户，当它产生了账户超过总数的一半，它就有控制权了，就可以操纵投票结果

比特币系统当中每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放到这个区块里，然后就开始尝试各种 nonce 值（4 bytes），看哪一个能够满足不等式的要求。如果某个节点找到了符合要求的 nonce 就说他获得了记账权（往比特币这个去中心化的账本里写入下一个区块的权利）。

其他的节点收到区块之后，要验证其合法性（block header的内容是否正确（比如其中的nbits域是否符合比特币协议中规定的难度要求）、该区块的发布者是否有记账权、block body中的交易是否合法（有交易的签名、没有double spending）等等）。

如果一个区块经过检查都是符合要求的，节点也不一定能够接受它。因为发布者可能把该节点插入到了区块链的另一个分支上，造成分叉攻击。

分叉攻击（forking attack）：因为要验证某个区块上的交易是不是合法，只能够根据区块间的哈希指针查到同一分支上的区块，查不到平行分支上的区块。所以有可能通过往区块链中间位置插入一个区块，来回滚某个已经发生了的交易。

![image-20221011094004893](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221013102458999.png)

所以即使某个区块的内容都是合法的，如果不在最长合法链上，也是不会被接受的。

但是当多个节点同时获得记账权时，区块链在正常情况下就可能出现两个等长的分差。此时按照最长合法链原则的话，两个都是最长合法链。比特币协议当中，缺省情况下，每个节点接受的区块是其最早收到的那个，不同节点根据在网络中的位置不同，在出现等长的分叉时会接受（如果该节点沿着某个区块往下继续扩展，就算是认可的区块（implicit consent））不同的区块。

如果系统中出现两个节点差不多同时发布区块的情况，那么这种等长临时性的分叉会维持一段时间，直到其中有某一个分叉被其他的节点接受，或者是自己又再一次获得了记账权，将新区块发布到之前的区块后，那这个分支就变成了最长合法链。另一个分支上的区块叫做 orphan block，就会被丢弃。

![image-20221011101958018](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221001223706955.png)



争夺记账权有什么好处？首先，获得记账权的节点本身有一定的权利，可以决定哪些交易被写到下一个区块里。但是因为凡是合法的交易都应该能够被写入到区块里，所以这个不是争夺记账权的主要动力。更重要的是记账权带来的初块奖励(block reward)。

比特币协议中规定获得记账权的节点，在发布的区块里可以有一个特殊的交易——铸币交易（Coinbase transaction），在这个交易里可以发布一定数量的比特币。这是比特币系统当中发行新的比特币的唯一方法，其他所有的交易都只不过是把已有的比特币从一个账户转移到另外一个账户，没有产生新的比特币。这个交易不用指明币的来源，是凭空造出来的。

比特币刚上线的时候，每一个发布的区块可以产生 50 个比特币。但是协议中规定 21 万个区块以后，这个初块奖励就要减半，区块里就只能发行 25 个比特币。再过 21 万个区块又要减半，就变成了 12.5 的比特币。



比特币系统中要取得的共识就是这个去中心化账本里的内容。因为要通过解Puzzle来获得记账权，由于puzzle friendly的性质，保证了求解这个 Puzzle 的过程没有捷径，只能一个个 nonce 去试。这就是比特币中投票的特殊性：它不是一人一票，也不是一台计算机一票，而是看每秒钟能够试多少个 nonce 的数目（ hash rate），节点的hash rate 越高，那么获得记账权，得到初块奖励的概率也是越大的。所以我们说比特币的共识机制是靠算力来投票。

比特币这个争夺记账权的过程叫做挖矿（mining），争夺记账权的节点被称为矿工（miner）。如果获得了记账权，有时候就说他挖到矿或者说是挖到区块，区块链中的每个区块理解成这么挖出来的。



# 4. BTC-系统的实现



## 账本模式

区块链是一个去中心化的账本，比特币采用的是基于交易的账本模式（transaction-based ledger）。

每个区块里记录了交易信息，有转账交易、铸币交易。但是系统当中并没有显示地记录每个账户上的余额。当要知道账户的余额时，需要通过区块链中的交易记录来推算。

区块链上有很多交易，有些交易的输出可能已经被花掉了，有些还没有被花掉。所有还没有被花掉的交易的输出组成了集合——utxo。比特币系统的全节点要维护 utxo（unspend transaction output，没有被花出去的交易的输出）的数据结构。

注意：一个交易可能有多个输出，同一个交易输出可能有的在utxo里面，有的输出不在utxo。

utxo 集合当中的每个元素，要给出产生这个交易的输出的哈希值，以及在这个交易里是第几个输出，这两个信息就可以定位到这一个 utxo 中的输出。

为了检测 double spending 需要查一下 utxo 中是否有想花掉的币，只有在这个集合里面才是合法的，所以全节点要在内存中维护 utxo 这样一个数据结构，以便快速检测 double spending。

随着交易的发布，每个交易要消耗一些 utxo 的输出，又会产生一些新的输出。utso 的集合是逐渐增大，但是到目前为止，装在一个普通的服务器的内存里还是完全没有问题的。

每个交易可以有多个输入，也可以有多个输出，所有输入的金额加起来要等于所有输出的金额：$$ \text { total inputs = total outputs }  $$

有些交易可能 total input 略微大于 total output。其中的差额作为交易费给获得记账权发布区块的节点。

获得记账权发布区块的节点除了有一个特殊的 coinbase transaction 获得一定数量的比特币作为 block reward 之外，还需要把交易打包到区块中。因为在区块中打包交易有一定的代价，如：要验证这个交易的合法性、区块占用的带宽也比较多导致在网络上传播的速度减慢等等。所以为了激励区块打包交易，把交易打包到这个区块会给产生区块的节点一定的 transaction fee。目前比特币系统当中，交易费的金额都很小。

因为比特币中的出块奖励是逐渐减小的，每隔 21 万个区块（整个系统平均每隔 10 分钟会产生一个新的区块，4年时间会就会产生21万个区块）要减半。多年以后，这个初块奖励变得就很小了，到那时交易费可能就变成主要的激励。

除了比特币这种 transaction base 的 ledger 之外，与之对应的还有另一种模式是基于账户的模式。以太坊用的就是基于账户的模式。在这种模式当中系统是要显示的记录每个账户上有多少币。

## 具体区块的信息

[blockchain](https://www.blockchain.com/explorer)

![image-20221013102458999](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221015223248421.png)

- Transactions：区块中包含的交易数
- Fees：所有交易总的交易费
- Reward：出块奖励
- Height：区块的序号
- Difficulty：挖矿的难度，每隔 2016 个区块要调整这个难度，保持出块时间在 10 分钟左右
- Nonce：挖矿时尝试的随机数，最后找到的符合难度要求的
- Hash：区块块头的哈希值，计算哈希值的时候都是只算 block header 不包含 block body 中具体的交易列表。
- Merkle Root：区块中包含的交易构成的 merkle tree 的根哈希值



```cpp
/** Nodes collect new transactions into a block, hash them into a hash tree,
 * and scan through nonce values to make the block's hash satisfy proof-of-work
 * requirements.  When they solve the proof-of-work, they broadcast the block
 * to everyone and the block is added to the block chain.  The first transaction
 * in the block is a special one that creates a new coin owned by the creator
 * of the block.
 */
class CBlockHeader
{
public:
    // header
    int32_t nVersion;
    uint256 hashPrevBlock;      //  uint为无符号整数。
    uint256 hashMerkleRoot;
    uint32_t nTime;                       // 区块产生的时间
    uint32_t nBits;                         //  挖矿时用的目标阈值，只能按照协议中的要求定期进行调整，不能随便改
    uint32_t nNonce;
```



如今挖矿难度已经被调的非常高，单纯靠调整 block header 里这个 nonce 大概率是找不到符合要求的，搜索空间不够大。

此时需要修改 merkle tree 的根哈希值：每个发布的区块里有一个特殊的铸币交易 coinbase transaction 这是比特币系统中产生新的比特币的唯一方式。这个交易没有输入，但有一个 coinbase 域，可以写入任何的内容。改变这个域的内容之后，这个交易的哈希值就发生了变化，这个变化会沿着 merkle tree 的结构往上传递，最后导致 block header 里的根哈希值发生变化。所以我们可以把这个域当做 extra nonce，块头里四个字节的 nonce 不够用。这里还有很多字节可以用。比如把 coin base 这个域的前八个字节当作 extra nonce 来用，这样搜索空间就增大了到了 2 的 96 次方。所以真正挖矿的时候是有两层循环，外层循环调整这个 coin base 域的 extra nice 算出 block header 里的根哈希值之后，内层循环再调整 header nonce。

交易的输入和输出都是用脚本的形式来指定的。比特币系统中验证交易的合法性，就是把 input script 和 output script 配对后执行来完成的。

注意：并不是把同一个交易里的输入脚本和输出脚本配对，而是把交易里的输入脚本跟前面那个提供币的来源的交易里的输出脚本配对。如果输入脚本和输出脚本拼接在一起，能够顺利执行，那么这个交易就是合法的。



## 挖矿概率分析

挖矿就是不断的尝试各种 nonce 来求解 Puzzle， 每次尝试 nonce 可以看作是一个 Bernoulli  trial（a random experiment with binary outcome）。

对于挖矿来说，成功和失败的概率是不一样的，每次尝试一个 nonce 成功的概率是微乎其微的，大概率是不行的。如果做很多的Bernoulli  trial，每个实验都是随机的，那么这些 Bernoulli  trial 就构成成为一个 Bernoulli process（A sequence of independent Bernoulli trial）

Bernoulli process 的一个性质是无记忆性（memoryless property），前面的实验结果对后面的实验是没有影响的。对于挖矿来说，每次尝试 nonce 成功的可能性很小，需要尝试大量的 nonce 才有可能找到符合要求的。这种情况下，这个 Bernoulli process 可以用Poisson process 来近似。

我们关心的是出块时间（系统里产生下一个区块的时间），这个在概率上可以推导出来，这个出块时间是服从指数分布（exponential distribution）

![image-20221015223248421](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221002172105310.png)

纵轴是概率密度，横轴是出块时间（time to next block）是整个系统的出块时间，并不是每个具体旷工的出块时间，整个系统平均的出块时间是 10 分钟。

这个平均时间是比特币协议设计出来的，通过定期的调整挖矿难度，使得平均的出画时间维持在 10 分钟左右。具体到每一个矿工，能够挖到下一个区块的时间，取决于这个矿工的算力占系统总算力的百分比。

这个指数分布也是无记忆的（memoryless）。这个概率密度曲线从任何一个地方把它截断，剩下这部分曲线的形状跟原来是一样的，仍然是服从指数分布，这就是 memoryless 的性质。也就是将来还要挖多少时间，跟过去已经挖多少时间是没有关系的，平均还是要 10 分钟。所以这个性质也叫 progress free。

如果不满足这个性质，算力强的矿工会有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的，那么算力强的矿工获得记账权的概率就会大于它所占的算力的比例。



## 比特币的总量

出块奖励 block reward 是系统中产生新的比特币的唯一途径，而这个出块奖励是每隔四年要减半的，这样产生出来的比特币数量就构成了一个几何序列（geometric  series）。

一开始的时候，21万个区块能够生成的比特币是 50 个。那么接下来的 21 万个区块能够生成的比特币就变成了 25 个。再往下的 21 万个区块变成了12.5。那么以此类推。

![image-20221015225101435](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221020205315159.png)

系统中所有比特币的总量为2100万。

比特币求解的 Puzzle 除了比拼算力之外没有其他的实际意义。比特币越来越难被挖到，是因为初块奖励被人为的减少了。比特币的稀缺性是人为造成的。

虽然挖矿求解 Puzzle 本身是没有什么实际意义的，但是挖矿的过程对于维护比特币系统的安全性是至关重要的（Bitcoin is secured by mining）。对于一个去中心化的没有 membership 控制的系统来说，挖矿提供了一种凭借算力投票的有效手段。只要大部分算力是掌握在诚实的节点手里，系统的安全性就能够得到保证，挖矿机制的设立对于维护整个系统的安全性是非常有效的。



## 比特币的安全性

挖矿给出的只是个概率上的保证写入区块的交易都是合法的，但是不能保证记账权不会会落到有恶意的节点手里。



Q：恶意节点能否偷币，把别人账上的钱转给自己？

A：不能，因为不知道私钥，伪造不了签名。即使把这个交易硬写到区块链里了，因为它包含一个非法的交易，诚实的节点并不会接受这个区块。诚实的节点会继续沿着上一个区块挖。有恶意的攻击是否成功的标准是要看能否被诚实的节点所接受。因为包含了一个不合法的交易，所以这个区块实际上等于作废了，这对于这个攻击者来说，得不到初块奖励了



Q：能否把已经花出的币再花一遍 double spending ？

A：如果把转给其他节点的币，在自己刚挖到的区块中再填入转给自己的交易，这个区块如果是直接连在最后，是很明显的 double spending 凡是诚实的节点都不会接受这个区块。这个区块如果利用分叉攻击 forking attack ，这是取决于其他节点沿着哪一个链往下扩展，最后有一个会胜出，另一个就作废了。拥有较大的算力的话理论上是可能的。



Q：那么怎么防范这种攻击呢？

A：如果这个转账交易不是在最后一个区块，而是后面又跟了几个区块的话，这样如果插在保存该交易的区块的平行处，这种攻击的难度就会大大增加，因为该区块不再最长链上，不会被诚实节点接受。所以一种简单的防范这种攻击的方法就是多等几个区块发布在确认交易。交易刚刚写到这个区块里的时候，称为 one confirmation，以此类推，要等六个confirmation，到这个时候才认为前面这个交易是不可篡改的。

A：还有一种叫 zero confirmation （账交易发布出去了，但是还没有被写到区块链里）。此时也是比较安全的，因为节点一般会接受最早收到的区块，因为插入的包含不合法的交易的区块发布时间较晚，一定程度上诚实的节点并不会接受该区块。另外，对电商平台来说，从支付成功到发货是有一定的时间间隔的，天然有一定的处理时间。

![image-20221015232223199](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221015225101435.png)

> 区块要插入的位置，是要在刚开始挖矿的时候就要决定了，因为设置的 block header 里要填上前一个区块的哈希，所以 M 这个节点想插到这个位置的话，一开始就要把这个区块设置成前一个区块，而不是说等获得了记账权以后再说。

> 区块链是不可篡改的账本（Irrevocable ledger）：并不是说凡是写入区块链的内容就永远都改不了，这种不可篡改性只是一种概率上的保证，刚刚写入区块链的内容相对来说还是比较容易被改掉的。经过一段等待时间之后，或者说后面跟着好几个确认之后，被篡改的概率就会呈现指数级别的下降。



Q：如果某个有恶意的节点获得记账权，故意不把某些合法的交易写到区块链里，故意不包含某些交易。怎么办？

A：合法的交易反正可以被写到下一个区块里，总有诚实的节点愿意发布这些交易。其实，区块链在正常工作情况下也会出现合法的交易没有被包含进去的情况。因为比特币协议中规定每个区块的大小是有限制的，最多不能超过 1 兆字节。可能因为这段时间交易的数目太多了，那么有些交易可能就只能等到下一个区块再发布。



Q：包含不合法交易的区块先不发布，而是在这个区块后面继续挖，等到此时的链较长时，再将所有的区块全部发布（selfish mining），让这条包含不合法交易的区块所在的链成为最长链。

A：普通的矿工这么做成功的可能性仍然是不大的。因为相较于诚实节点总的算力来说，恶意节点的算力太小了，几乎无法将自己的链挖成最长链。只有在算力占系统算力的一半以上，这种成功的可能性才会比较大。

A：另外 selfish mining 可以一定程度上减少竞争。如果挖到后立即发布出去的话，大家一起抢着挖下一个。如果挖到后先不发布，其他节点都在浪费算力挖之前的，就没有算力竞争计算藏着的区块的后续区块，让其他节点做些无用的功。但是这样风险很大，如果在挖藏着的区块的后续区块之前，其他的节点挖到了区块并发布了出去。这时候最长链就不包含藏着的区块了，要赶快把未发布的区块发布出去，否则可能该区块就会作废。



# 5. BTC-网络的工作原理

比特币系统的工作过程是用户把交易发布到比特币网络上，节点收到这些交易之后把它们打包到区块里，然后把区块也发布到比特地网络上。新发布的交易、新发布的区块在比特币网络上是怎么传播的呢？

## 比特币的网络

比特币系统工作在应用层，它的底层是一个 p2p Overlay Network。

![image-20221016180710251](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221020205711806.png)

比特币的这个 P2P 网络是非常简单的，所有节点都是对等的，不像有的 P2P 网络有所谓的超级节点 super node 或者主节点master node 

如果要加入这个网络，首先要至少知道有一个种子节点（seed node），然后和种子节点联系，他会告诉你所知道的网络中的其他节点。节点之间是通过 TCP 通信，这样有利于穿透防火墙。离开的时候只需要退出应用程序，别的节点没有听到你的消息，过了一段时间之后就会把你删掉。



比特币网络的设计原则是简单鲁棒，而不是高效 simple, robust, but not efficient。每个节点维护一个邻近节点的集合，消息传播在网络中采取叫 flooding 的方式：节点第一次听到某个消息的时候，把它传播给其他的所有邻居节点，同时记录一下，这个消息已经收到过了。下次再收到相同消息的时候，就不用再转发给邻居节点了。邻居节点的选取是随机的，没有考虑底层的拓扑结构。这样的设计鲁棒性非常强，但是牺牲的是效率。向身边的人转账，跟向美国转账速度其实是差不多的。

## 交易的传播

比特币系统中，每个节点要维护一个等待上链的交易的集合。

当节点第一次听到某个交易的时候，确认这个交易是合法（有合法的签名，之前没有被花过）的话，就会把这个交易加入这个集合，并且转发给邻居节点，以后再收到这个交易的时候就不用转发了，这样避免这个交易会在网络上无限的传输下去。

这里可能会产生 risk condition 有两个有冲突的交易差不多同时被广播到网络上。此时每个节点根据在网络中的位置的不同，不同的节点可能收到不同的交易。当交易的是同一个币，接受了一个交易之后，后面冲突的交易就不能在加入这个集合中了。

当集合中的某个交易或与之冲突的某个交易被写到区块链中时，该交易就会被从这个集合中删掉。

## 区块的传播

新发布的区块，在网络上的传播方式跟新发布的交易是类似的。

每个节点除了要检查区块内容的合法性之外，还要检查是否在最长合法链上。

越是大的区块在网络上传播的速度就越慢，比特币协议对于区块大小限制为 1M。因为比特币网络采用的传播方式是非常耗带宽的，带宽是瓶颈。按照 1M 的区块大小限制来算的话，一个新发布的区块有可能需要几十秒才能传播到网络上的绝大多数节点，这个已经是挺长时间了。



最后，比特币网络的传播是属于 best effort。

- 一个交易发布到比特币网络上，不一定所有的节点都能收到。
- 网络传播存在延迟，导致不同的节点收到交易的顺序也不一定是一样的。
- 有的节点不一定按照比特币协议的要求进行转发，导致其他节点收不到某些合法的交易，而收到一些不合法的交易。

这就是一个去中心化的系统中面临的实际问题。



Q：当需要回滚交易时怎么做？

A：比特币系统是个区块链，要回滚的话特别麻烦。另外像银行转账这种支付方式出现退还的交易也不是通过回滚的方法准，而是通过产生一个新的交易进行退还，是两个独立的交易。



# 6. BTC-调整挖矿难度



## 挖矿难度

挖矿就是不断的尝试 block header 里的nonce 值，使整个 block header 的哈希值小于等于给定的目标阈值。

调整挖矿难度就是调整目标空间在整个输出空间中所占的比例，target 越小，挖矿难度是越大。

比特币用的哈希算法是 SHA-256 （secure hash algorithm），产生的哈希值是 256 位，所以整个输出空间是 2 的 256 次方。

调整目标空间占输出空间的比例，通俗的说就是哈希值前面要多少个0，就比如说 256 倍的哈希值，要是合法的区块要求算出来的哈希前面至少有 70 个0。严格来看这是不准确的。

另一种概念是挖矿难度，它是和目标阈值是成反比的。

$$\text { difficulty }=\frac{\text { dificulty _1_ target }}{\text { target }}$$

difficulty 1 target 是指挖矿难度等于 1 的时候所对应的目标阈值。挖矿难度是最小就是 1 。这个时候对应的目标阈值是个非常大的数，因为此时目标空间占的比例非常大，所以这时挖矿是越容易的。



## 调整的原因

- 系统里的总算力越来越强，如果难度保持不变的话，那么这个出块时间越来越短，虽然这样可以提高系统的响应时间，但是如果出块时间远远小于区块在网络上传播的用的时间，非常容易出现分叉。过多的分叉对于系统达成共识是没有好处的。

- 危害系统的安全性。因为如果出现了很多个分叉，那么这个时候系统里的总算力就被分散了。节点根据在网络中位置的不同，可能会选择沿着其中的某个分叉继续往下扩展。而有恶意的节点可以集中算力扩展它的分叉，此时很快就可以使这个分叉变成最长合法链，因为诚实节点的算力被分散，这时可能不需要 51% 的算力就能发动攻击了。所以出块时间不是越短越好。（只是说出块时间要有一个常数的波动范围，不能无限的减小下去，要有一个常数的波动范围）

  > 比特币协议是假设大部分算力掌握在诚实的矿工手里，系统当中的总算力越强，安全性就越好。因为你要发动 51% 攻击（51% attack），所需要的算力就越大。

  > 比特币中的 10 分钟的出块时间有点太长了，对于一个支付系统来说，一个支付要等长时间才能得到确认。以太坊里的出块时间就降低到了 15 秒，所以以太坊的出块速度是比特币的 40 倍，这个出块时间大幅度下降之后，以太坊就有一个新的共识协议，叫ghost。在这个协议当中，这些分叉产生的orphan block 就不能够简单的丢弃，而是也要给他一些奖励，叫做 uncle reward。
  >
  > 以太坊中同样需要调整挖矿难度，使得出块时间保持稳定，它降到 15 秒以后，这个 15 秒也要设法保持稳定。

平均出块时间到底设计成多长，这个没有一定之规，但是不论设计成多长，都需要保持稳定，而不能无限的减少下去。



## 具体调整

比特币协议中规定的是每隔 2016 个区块要重新调一下这个目标阈值，根据出块时间是十分钟，大概是每两个星期调整一下。

$$\text { target }=\text { target } \times \frac{\text { actual time }}{\text { expected time }}$$

- actual time（time spent mining the last 2016 blocks）。
- expected time：理想状况下每 10 分钟产生一个区块，产生 2016 个区块的预期时间

如果实际时间超过了两个星期，说明平均下来出块的间隔超过了 10 分钟，那么挖矿难度应该调的低一点，乘完之后这个 target 会变大，挖矿难度就降下来了。如果这个实际时间是小于两个星期的，说明这个出块速度有点太快了，那么这时候应该提高挖矿的难度，最终target 变小。

为了避免系统中出现意外情况，导致这个目标阈值极端的情况。实际代码当中，上调和下调都是有四倍的限制。比如说这个实际时间超过了八个星期，算的时候也只按照 8 个星期来算，目标阈值增大最多也是增大四倍。相反的，如果这个时间非常短，不到半个星期就把这个2016 个区块都出完了，这时也按照半个星期来算，最小它也是1/4。

Q：怎么才能让所有的矿工同时调整目标阈值？

A：block head 中有一个 nBits 域，是 target 的一个编码的版本。target 是256位的（4个字节），block header 里没有直接存储 ，而是存储的只有四个字节的nBits。因为每个节点要独立验证发布的区块的合法性，检查的内容就包括这个 nBits。 如果该域不正确，这个区块是不会被接受的。

> 以太坊也要定期调整把控难度，但它不是说隔多少个区块，而是每个新出的区块都有可能进行调整。



比特币成功其实并不是因为它更实用，从某种意义上说是因为它更不实用。比特币是没有任何真正法币背书的，完全是凭空造的货币。其中的很多参数：出块时间、每个块的大小等等，是不是最优的，有争议。

比特币系统中总算力的变化情况：

![image-20221020205315159](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221016180710251.png)

即使是在黄金时期，算力也不是单调递增的，中间也是有很多波动，但总的来说是增长得非常快的。

挖矿难度的变化情况：

![image-20221020205536500](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221021084103386.png)

挖矿难度的变化情况和算力的增长基本上是同步的，也符合难度调整的设计目标。通过调整挖矿难度，使得出块时间保持稳定。注意：挖矿难度不是目标阈值

最近半年的难度调整曲线：

![image-20221020205711806](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221020205536500.png)

很明显的是一段一段的，每隔两个星期难度上一个台阶，说明挖矿的人越来越多，用的设备越来越先进，反映出大家对比特币的热情越来越高。如果出现相反的情况，某个加密货币的挖矿难度越调越小，说明挖矿变得越来越容易了，大家对这个币的热情是逐渐减少的。



挖矿难度：

$$next\_difficulty= previous\_difficulty *
(2 weeks) / (time\ to\ mine\ last\ 2016\ blocks)$$



# 7. 挖矿

## 全节点和轻节点的职责

比特币中有两种节点，一种是全节点，一种是轻节点。

全节点：

- 一直在线的
- 本地硬盘上维护完整的区块链信息
- 内存当中维护 utxo 集合(unspend transaction output 集合)，以便快速检验交易的正确性
- 监听比特币网络上的交易信息，验证每个交易的合法性（有没有合法的签名、是不是 double spending）。
- 决定哪些交易会打包到区块里。在缺省状况下，只要是合法的交易，并且交易费符合要求就会被打包进去。
- 监听别的矿工挖出来的区块，验证其合法性。（每个交易都要合法，包括这个铸币的 coinbase transaction、有没有篡改 block reward、有没有篡改区块的难度要求等等。简单的说检查一下 block header 取哈希值之后，前面有没有足够多的零。全节点每两周要按照比特币协议的要求调整挖矿难度。检查一下区块是否在延伸最长合法链上）
- 挖矿。分为两部分：第一个要决定沿着哪条链挖下去，缺省情况下应该是沿着最长合法链挖下去。当出现等长的分叉的时候，缺省情况下是选择最先听到的分叉

轻节点（spv client，simplified payment verification）

- 不是一直在线
- 不用保存整个区块链的信息，只要保存某每个区块的 header 就可以了。存储整个区块和只存 block header 差有 1000 倍的大小。

- 不用保存全部的交易，只要保存与自己相关的那些交易就行了。因为没有保存完整的交易信息。那么也没有办法验证大多数交易的合法性。只能检测与自己相关的那些交易的合法性。
- 无法检测网上发布的区块的正确性，因为没法检测这个区块里所包含的交易是不是合法的。
- 可以验证挖矿的难度。因为挖矿的时候计算哈希值只用到了块头的信息，轻节点虽然没有办法检查网上发布的这个区块所包含的交易的合法性，但是可以检查发布的这个区块是符合难度要求的。假设发布这个区块的全节点是不会把非法的交易发布出来的。

- 只能检测哪个是最长链，不知道哪个是最长合法链。因为没有办法检测这条链上所包含的交易都是合法的，但是可以检测这条链上所包含的区块都是符合挖矿难度要求的。假设矿工是有理智的，不会沿着不合法的链挖下去。



比特币网络中大部分节点都是轻节点，如果只是想进行转账，不需要挖矿的话，那么没必要运行一个全节点。

Q：在挖矿过程中，如果你监听到别人发布了一个区块，这个区块是合法的，也是在延伸最长合法链。这时候应该怎么办？

A：应该停止已有的挖矿，然后重新在本地组装一个候选区块，然后重新进行挖矿。因为如果要沿着这个新发布的区块往下挖的话，那么本地所组装的这个区块中包含的交易就会发生变化，有些交易可能已经被包含到新发布的这个区块里面。另外 block header 的内容也会变化，像 block header 里有这个交易所组成的 merke tree 的根哈希值，还有这个指向前一个区块的指针，这些也都会发生变化，所以要停止已有的挖矿，重新组装一个候选区块，然后从头开始挖。

Q：那这样做是不是有些可惜？

A：其实不可惜的。因为挖矿是无记忆性（memoryless 或者 progress free）。所以，无论是继续挖原来的区块，还是说停下来改成挖一个新组装出来的区块，成功的概率是一样的。只要当前还没有挖到符合要求的 nonce，前面已经挖了多长时间其实是没有关系的，对最后的结果没有影响。所以这个是并不可惜的。

另外，即使挖到了合法的区块，把它发布到区块链上也不是说就胜利了。有可能发布的这个区块最终没有成为最长合法链，可能存在一些 risk condition，别人同时发布一个合法的区块，或者存在一些不知道的 double spending 使得你这个区块中某些交易最后变成是有冲突的。

Q：比特币是怎么保证安全性？

A：比特币当中的安全性是从两方面来保证的。一方面是密码学上的保证，另一方面是共识机制。密码学的保证是别人没有你的私钥，就没有办法伪造你的签名，产生私钥的时候以及签名的时候都要有好的随机源，产生的随机数要足够随机，所以也就不能够把你账上的钱转走。这个的前提是系统中拥有大多数算力的矿工是是遵守协议的，不会接受那些没有合法签名的交易。如果没有这一点的话，那么密码学上的保证也就没有用武之地，

## 挖矿的设备

挖矿设备的演化趋势是越来越趋于专业化。

1. 最早的时候是用普通的 CPU 挖矿，如果一台计算机专门是用来挖矿的话，其实是非常不划算的。挖矿只用到其中很少一部分内存，大部分内存都是闲置的。因为挖矿当中计算哈希值的操作只用到了通用 CPU 中很少一部分指令，CPU当中的大部分部件也是闲置的。另外硬盘和其他很多资源也都是闲置的。随着比特币挖矿难度的提高，用 CPU 挖矿，用通用计算机挖矿，因为性价比太低，很快就变得是无利可图了。
2. 第二代是GPU。GPU 挖矿比 CPU 挖矿的效率已经是提高了很多了。GPU 主要是用于大规模的并行计算，像深度学习里面用 GPU 就用的很多，有大量的矩阵乘法。但是 GPU 用来挖矿其实还是有点浪费的。GPU 是为了通用并行计算而设计的，用来挖矿的话，里面有很多部件仍然是处于闲置状态，比如说用于浮点数运算的那些部件，比特币的挖矿只用到了整数操作，所以 GPU 挖矿比 CPU 效率有很大提高，但仍然是有不少的浪费。比特币挖矿难度的提升，用 GPU 挖矿已经是划不来了，它已经超过了 GPU 的算力范围。有一些新开发的这些加密货币，有的还用 GPU 挖矿。
3. ASIC 芯片（Application Specific Intergrated Circuit）。整个芯片就是为了比特币挖矿计算哈希值的操作而设计的，上面没有多余的电动逻辑，所以它的性价比是最高的。而且为某一种加密货币设计的 AC 的芯片只能挖这种加密货币，挖别的就不行。除非这两个加密货币用同一个 mining Puzzle。有些加密货币在新发行的时候，为了解决启动问题，故意用一个已有的加密货币的 mining  Puzzle 比如说跟比特币一样的 money paro 这样可以吸引更多的人来挖矿（merge mining）。 

> ASIC 芯片的研发周期是很长的，在比较长的周期里面，如果比特币的价格出现剧烈的变化的话，那么前期投入的研发费用有可能就打水漂了。如果比特币价格大幅度下降的话，那么挖矿可能是赔本的，可能还抵不上电费。这就是用 ASIC 芯片挖矿的一个情况。
>
> 一款 asic 矿机刚刚上市的时候，大部分的利润是在它上市的前两个月获得的，因为这个时候它的算力是在同类产品当中是最强的，基本上他头两个月就能够获获得他这个整个生命周期当中一半以上的利润，再往后可能就要被淘汰掉，会有更强的矿机出来。ASIC 矿机一般来说都是需要提前预定的，如果厂商不能够及时交货的话，那么对矿工是个很大的伤害。有些不良的厂商，把 ASIC 矿机生产出来之后，不马上提供给这个用户，而是自己用这些矿机先挖矿，挖一段时间赚取比特币，等到最赚钱黄金时间的头两个月过去之后才把这个矿机发给用户。
>
> 比特币系统当中算力突然有了一个明显的提高。这个时候一般是某个大的厂商，它的一款新的矿机生产出来了。所以说在比特币浪潮中，真正赚大钱的不一定是那些挖矿的可能是卖矿机的。

挖矿设备总的演化趋势是从通用变成用越来越专用，CPU是属于通用计算， GPU 是通用并行计算， asic 挖矿专用。

最民主的一种情况是大家就用 CPU 去挖矿，就用普通家里的计算机。进入到 GPU 时代之后，用普通家里的计算机挖矿就已经比较困难。而且 GPU 的噪音比较大。有些新的加密货币，它设计的叫 alternative mining Puzzle ，设计这些 mining Puzzle 的一个出发点是 ASIC resistance，目的是让通用的计算机也能够参与挖矿。

## 矿池

挖矿的另一个趋势是大型矿池的出现。

矿工即使是使用 ASIC 芯片挖矿，从平均收益上看是有利可图的，但是它的收入是非常不稳定。如果具体到某一个矿工来说，他可能要挖很长的时间才能挖出一个区块。另外，单个矿工除了挖矿之外，还要承担全节点的其他责任。

矿池是把矿工组织起来作为一个整体。矿石的架构一般来说是一个全节点驱动很多矿机。一个矿池一般有一个矿主，这个 pool manager 下面连着很多矿工miner。矿工只负责计算哈希值其他的功能，全节点的其他职责都由矿主 pool manager 来承担。ASIC 芯片只能负责计算哈希值，它不能干全节点的其他功能。

矿石的出现还有另外一个目的是解决收入不稳定的问题。单个矿工的收入是不稳定的，所以大家合在一起干，有了收益之后，大家一起分配一下。那么这就牵扯到一个收益该如何分配的问题。

矿池一般来说有两种组织形式，一种是像大型数据中心，这些矿机是属于同一个机构的，那么这个收入怎么分配就无所谓了。第二种组织方式就是分布式的，矿机是来自于不同机构的，矿工要加入一个矿池，就按照矿池规定的通讯协议跟这个矿主进行联系，矿主把要计算的哈希值的任务分配给矿工，计算完之后把这个结果返回给这个矿主。然后将来有这个出块奖励的时候一起参与分红。此时要按照每个矿工的贡献大小进行分配。也就是工作量证明。矿主把挖矿的难度降低然后交给矿工完成，这样挖到的叫做一个share（almost valid block）。矿工挖到这样的 share 之后，提交给矿主，矿主拿到这个区块除了作为证明矿工所做的工作量之外，没有其他用处。因为这个区块不是合法的，所以矿主不可能把这个区块发布出去。将来等到某个矿工真正挖到了合法的区块之后，再把这个初块奖励按照每个矿工所做的这个工作量提交的 share 数目进行分配。



Q：有没有可能某个矿工挖到一个合法的区块之后，不把它提交给矿主，而是自己偷偷发布出去得到初块奖励？

A：是不可能的。矿工的任务是由矿主来分配的，矿主负责组装好一个区块，可能把不同的 coinbase parameter 所对应的 nonce 值的范围交给不同的矿工去尝试。coinbase 中有一个收款人的地址，这个地址填的是矿主 pool manager 的地址。所以矿工挖到这个区块之后，如果她不提交给矿主的话，他自己发不出去是没有用的。



Q：如果一开始就不管这个矿主的任务，自己组装一个区块，偷偷的把这个收款地址改成他自己的地址会怎么样？

A：这样的话提交 share 给矿主的话，矿主是不认的。因为你里面那个交易列表已经被改过了。在 coinbase transaction 的内容发生变化，算出的这个 merkle tree 的根哈希值是不一样，所以这种情况矿组是不会给他认为是工作量证明的。就相当于这个矿工从一开始就是自己单干，跟矿池是没关系的。



Q：有没有可能捣乱？挖到一个真正合法的区块之后，就不提交而是把它丢弃掉。

A：可能的，如果这个矿工想捣乱的话，他可以这样做，这样做对他来说并没有什么经济上的好处。但是矿池之间是存在竞争关系的，所以有可能为了打击竞争对手，故意派一些矿工加入到竞争对手的矿石里去挖矿，然后采用这种方法来起到一些搞破坏的作用。



![image-20221021084103386](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102142712231.png)

如果把所有在中国的矿池的算力作为一个整体来看的话，在比特币系统中是有绝对优势的。

如果看单个矿池的话，在 2014 年的时候，曾经有个叫 GHash.IO 的矿池，算力占到了全球算力的一半以上。这个在当时引起的一些恐慌，这一个矿池的算力就已经足以发动 51% 的攻击机了。GHash.IO 主动的把算力占比大幅度的减少，以免动摇大家对比特币的信心。

挖矿集中化的程度仍然是比较大的，几个大型矿池占了相当大的比重，但是没有哪个矿池占到一半以上，这样看好像比较安全了。但可能只是一个表面现象。假设某个机构有半数以上的算力，不一定要把所有的算力都放在一个矿池里，而是把这些算力分散隐藏在很多个矿池里。平时的时候是分散隐藏的，真正需要发动攻击的时候，在集中起来发动攻击。一般来说，矿池的矿主要收取一定比例的出块奖励作为管理费。那么有恶意的矿池在发动攻击之前，可能故意把管理费降的特别的低，吸引到足够锅的矿工加入之后，然后就可以发动攻击了。这个实际上是大型矿石的一个弊病，使得 51% 的攻击更加容易了。因为每个矿工只是负责计算哈希值，他并不知道这个网上有什么样的交易，发布过什么样的区块，并不知道这种 double spending 的出现，他根本就不知道攻击的存在。



Q：51% 的攻击具体能够发动哪些攻击呢？

A：

- 分叉攻击 forking attack。攻击者有 51% 的算力的话，下面矿池自己的链的平均增长速度是比上面这条链要快，所以它最终会成为最长合法链，到这时，之前的某些交易就会被回滚了。
- 封锁账户 boycott。如果想要封锁某个账户的话，所有跟这个账户相关的交易都不让上链。如果某个区块中包含了某个与该账户有关的交易，那么马上进行分叉，产生一个不包含这个交易的区块，公开抵制这样的交易。有半数以上的算力，它可以让这个分叉链变得更长。这样一来，别的矿工也不敢随便把这样的交易打包进去了。



大型矿石的出现有一定的好处，矿工只负责挖矿计算哈希枝就行了，给矿工减轻了负担，收入分配也更加稳定了。

但是矿石的出现也有一定的危害。发动 51% 的攻击变得容易了，不一定非要自己有这么多的算力，只要他能够动员着急起来这些算力就可以了。类似于这个云计算中说的叫 on demand computing，平时不用自己去维护很大的计算集群，需要用的时候可以随时召唤。那么这里实际上是 on demand mining。



# 8. BTC-脚本

## 交易实例

比特币的交易实例

<img src="http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221015232223199.png" alt="image-20221102141114234" style="zoom:67%;" />

比特币使用的脚本语言是非常简单的，唯一能访问的内存空间就是一个堆栈，不像通用的编程语言，有全局变量、局部变量、动态分配的内存空间等等。比特币的脚本语言是基于栈的语言 stack based language，每个输入和输出脚本都分别对应一个脚本。

交易的宏观信息（meta data）

![image-20221102141858291](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102141858291.png)

- txid：transaction ID 
- hash：交易的哈希值
- version：使用的比特币协议的版本
- size：交易的大小
- locktime：交易的生效时间。0表示立即生效，绝大多数情况下都是0，如果是非零值的话，那么这个交易要过一段时间才能生效。有一些比较特殊的 transaction 会用到 locktime
- vin 和 vout：交易的输入输出部分
- blockhash：交易所在的区块的哈希值
- confirmations：交易已经有多少个确认信息
- time：交易产生的时间
- blocktime：包含该交易的区块产生的时间



## 交易的输入

![image-20221102142712231](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102221311546.png)

交易的输入是数组，一个交易可以有多个输入。

每个输入都要说明花的币是来自之前哪个交易的输出。

- txid：该交易中币的来源的交易，是交易的哈希值
- vout：该币是在之前的交易里的第几个输出
- scriptSig：输入脚本。输入脚本最简单的形式就是给出一个 signature 就行了，证明有权利花这个钱。

如果一个交易有多个输入的话，每个输入都要说明币的来源，并且要给出签名。也就是说比特币中的一个交易可能需要多个签名。

## 交易的输出

![image-20221102143604234](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102141114234.png)

也是一个数组结构。这个例子当中是有两个输出

- value：输出的金额，就是给对方转过去多少钱。这里的单位是比特币，也有的地方是表示成 satoshi（聪，比特币里的最小单位） 
- n：序号，表示这是这个交易里的第几个输出
- scriptPubkey：输出脚本，输出脚本最简单的形式就是给出一个 public key
  - asm：输出脚本的内容，里面包含一系列的操作
  - reqSigs：输出需要多少个签名才能兑现。multi sig 多重签名，有的输出要多个签名才行。
  -  type：输出的类型，publickeyhash 公钥的哈希。
  - address ：输出的地址

## 脚本的执行

![image-20221102144729545](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102144729545.png)

B 转给 C 的这个交易的输入里，transaction ID 和 vout 指向的是 A 转给 B 的交易的输出。要验证这个交易的合法性，是要把 B 转给 C 的这个交易的输入脚本和 A 转给 B 的这个交易的输出脚本拼接在一起来执行的。

注意：前面交易的输出脚本放在后面，后面这个交易的输入脚本放在前面。在早期的比特币实现中，这两个脚本是拼接在一起，从头到尾执行一遍。后来出于安全因素的考虑，这两个脚本改为分别执行。首先执行输入脚本，如果没有出错，那么在执行输出脚本。如果能顺利执行，最后栈顶的结果为非零值，也就是true，那么验证通过这个交易就是合法的。如果执行过程中出现任何错误，这个交易就是非法的。如果一个交易有多个输入的话，那么每个输入脚本都要和所对应的交易的输出脚本匹配之后来进行验证，全都验证通过这个交易才是合法的。

## 输入输出脚本的形式

### P2PK（pay to public key）

![image-20221102221311546](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102225308104.png)

输出脚本：

- pubkey：之前的交易的收款人的公钥
- CHECKSIG：检查签名的操作

输入脚本

- Sig：付款人的签名。这个签名是用私钥对整个输入脚本所在的整个交易的签名

这种形式是最简单的，因为 public key 是直接在输出脚本里给出的。

注意：这里的收款人和付款人是同一个人。

![image-20221102222414464](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102222414464.png)

这是把输入脚本和输出脚本拼接起来之后的结果。第一行来自输入脚本，后两行来自输出脚本。出于安全考虑，这两段脚本实际上是分别执行的。

1. 把输入脚本里提供的签名压入栈
2. 把输出里提供的公钥压入栈。
3. CHECKSIG 是把占顶的这两个元素弹出来，用公钥检查一下这个签名是否正确。如果正确的话，返回处说明验证通过，否则的话执行出错。那么这个交易就是非法的。



### P2PKH（Pay to public key hash）

![image-20221102222902652](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102143604234.png)

与前者的区别在于输出脚本里没有直接给出收款人的公钥，而是公钥的哈希。输入脚本既要给出付款人的签名，也要给出付款人的公钥。输出脚本里其他还有一些操作，这些操作都是为了验证签名的正确性。这种形式实际上是最常用的。

![image-20221102223758578](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102222902652.png)

前两条语句来自输入脚本：

1. PUSHDATA (Sig) ：把付款人的签名压入栈
2. PUSHDATA (PubKey) ：把付款人的公钥压入栈

这些语句来自输出脚本：

1. DUP：把栈顶的元素复制一遍，所以栈顶又多了一个公钥。

2. HASH 160：把栈顶元素弹出来取哈希，然后把得到的哈希值再压入栈，此时栈顶变成了公钥的哈希值。

3. PUSHDATA (PubKeyHash) ：把输出脚本里提供的收款人的公钥的哈希值压入栈。此时栈顶有两个哈希值

   ![image-20221102225308104](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221102223758578.png)

4. EQUALVERIFY：弹出栈顶的两个元素，比较它们是否相等。这样做是为了防止有人冒名顶替，用他的公钥冒充之前的交易中收款人的公钥。假设这两个哈希值是相等的，那么就从栈顶消失了

5. CHECKSIG：弹出站顶的两个元素，用公钥检查这个签名是否正确，假设这个签名是正确的，那么整个脚本顺利运行结束，栈顶留下的是true。如果执行过程中任何一个环节发生错误，比如输入里给出的公钥跟输出里给出的哈希值对不上，或者是输入里给出的签名跟给出的公钥对不上，那么这个交易就是非法的。

pay to public key hash 是最常用的脚本形式。



### P2SH（pay to script hash）



![image-20221107173712918](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107173712918.png)

这种形式的输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的一个脚本的哈希。这个脚本叫 redeem script 赎回脚本，将来花这个钱的时候，输入脚本里要给出这个 redeem script 的具体内容，同时还要给出让这个赎回脚本能够正确运行所需要的签名。

验证的时候分为两步：

1. 验证输入脚本里给出的赎回脚本是不是和输出脚本里给出的哈希值匹配，如果不匹配的话，说明给出的赎回脚本是不对的，那么验证就失败了。如果正确则继续执行。
2. 然后把输入脚本中赎回脚本的内容当作操作指令来执行一遍，看看最后能不能顺利执行。如果两步验证都通过了，那么这个交易才是合法的。



redeemScript 的形式

- P2PK 形式
- P2PKH 形式
- 多重签名形式



**用 pay to script 实现 pay to public key**

![image-20221107175053866](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107190110807.png)

- 输入脚本给出签名，和序列化的赎回脚本

- 赎回脚本的给出公钥。然后用 CHECKSIG 检查签名，用来验证输入脚本里给出的赎回脚本是否正确。



第一阶段：（比较输入脚本和输出脚本中提供的赎回脚本的哈希是否相等）

1. 开始首先把输入脚本和输出脚本拼接在一起
2. 把输入脚本的 signature 压入栈
3. 把赎回脚本压入栈
4. HASH 160 取哈希的操作得到赎回脚本的哈希。
5. 把输出脚本里给出的赎回脚本哈希值压入站。这个时候这个站里就有两个哈希值了。
6. 最后用 equal 比较一下这两个哈希值是否相等，如果不等的话，那就 game over 了，假设这两个相等，那这两个哈希值就从站顶消失了。

第二阶段：（进行赎回脚本中的操作）

1. 首先要把输入脚本里提供的序列化的赎回脚本进行反序列化，这是每个节点自己要完成的。然后执行这个赎回脚本。
2. 把之前交易的收款人也就是现在的交易的付款人的公钥压入栈，然后用 CHECKSIG 验证一下输入脚本里给出的 signature 的正确性。验证通过之后，整个 pay to script hash 才算执行完成。



pay to script hash 这个功能在最初版本的比特币里面是没有的，后来通过软分叉的形式加进去了。它的一个常见的应用场景是对多重签名的支持。

比特币系统中一个输出可能要求多个签名才能把钱取出来。比如某个公司的账户可能要求五个合伙人中任意三个人的签名才能把这个公司账户上的钱取走。这样为私钥的泄露提供了一些安全人的保护。

![image-20221107181256922](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107181256922.png)

这个功能是通过 check multi SIG 来实现

输出脚本里给出 N 个公钥，同时指定一个阈值 M

输入脚本，只要提供这 N 个公钥对应的签名中任意 M 个合法的签名就能通过验证。

注意：

- 因为比特币中 check multi sick 的实现有一个 bug ，执行的时候会从堆栈上多弹出一个元素，因为这是个去中心化的系统，要想通过软件升级的方法去修复这个 bug 这个代价是很大的，要改的话需要硬分差，现在已经没有办法改了，所以实际采用的解决方案是在输入脚本里网站上多压进去一个没用的元素。

- 给出的这 M 个签名的相对顺序要跟他们在 N 个公钥中的相对顺序是一致的才行



执行过程：

1. 首先把这个多余的元素 false 压入栈内
2. 然后把输入脚本中提供的多个签名依次压入栈，输入脚本就执行完了。
3. 在输出脚本里，把 M 的值这个阈值 M 压入栈
4. 把输出脚本中提供的公钥压入栈
5. 然后把 N 的值压入栈
6. 执行check multi SIG 查看该堆栈里是不是包含了这三个签名中的两个。如果是的话，那么验证通过。

这个过程是用比特币脚本中原生的 check multi SIG 来实现的。早期的多重签名就是这样实现的。在实际应用当中，有一些不是很方便的地方，比如网上购物，就要求用户网上购物的用户在支付生成的转账交易里要给出给出五个合伙人的公钥，同时还要给出 N 和 M 的值。这就给用户生成转账交易带来一些不方便的地方，因为这些复杂性都暴露给用户了。这就要用到 pay to script hash。

用 pay to script hash 实现的多重签名，它的本质是把复杂度从输出脚本转移到了输入脚本。

现在输出脚本变得非常简单，原来的复杂度被转移到了这个 redeem script 赎回脚本里面。输出脚本只要给出这个赎回脚本的哈希值就行了。这个赎回脚本里要给出这 N 个公钥，还有 N 和 M 的值。这个赎回脚本是在输入脚本里提供的，也就是说是由收款人提供的。像网上购物的例子，收款人是电商，只要在网站上公布这个赎回脚本的哈希值，然后用户转账交易的时候，把这个哈希值包含在输出脚本里就行了。

![image-20221107184844854](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107175053866.png)



至于这个电商用什么样的多重签名规则，对用户来说是不可见的。用户没必要知道。从用户的角度来看，采用这种支付方式跟采用前面说的 pay to public key hash 没有多大区别，只不过把收款人公钥的哈希值换成了赎回脚本的哈希值。

执行过程：

第一阶段：验证赎回脚本的哈希的正确性。前四行为输入脚本，后面的为输出脚本

![image-20221107185613015](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107185613015.png)

1. false 为了应付 check multi SIG 那个 bug 而准备的一个没用的元素。执行的时候先把它压入栈，
2. 然后依次把两个付款人的签名押入站。
3. 然后压入序列化的赎回脚本，目前只是把它作为数据压入站到这里输入脚本就执行完了。
4. 继续执行输出脚本中的内容。HASH 160 对栈顶元素取哈希
5. 然后把输出脚本里提供的赎回脚本的哈希值压入栈
6. 最后判断一下这两个哈希值是否相等。

第二个阶段：执行赎回脚本

![image-20221107190110807](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221107184844854.png)

1. 先把 M 压入栈
2. 然后把收款人的公钥压入栈
3. 把 N 压入栈
4. 最后检查一下多重签名的正确性。三个里面有两个是正确的。

第二阶段的验证过程跟前面直接使用 check multi sick 的情况是类似的，现在的多重签名一般都是采用这种 pay to script hash 的形式。



### Proof of Burn

这种脚本格式是比较特殊的，这种格式的输出脚本开头是 return。

这个操作的作用是无条件的返回错误。所以包含这个操作的脚本永远不可能通过，验证执行到这个 return 语句就会出错，然后执行就终止了，不论输入脚本写的是什么内容，执行到输出的这个 return 语句它就报错了。那么这里的钱永远都花不出去。

这个脚本是证明销毁比特币的一种方法。

Q：为什么要销毁比特币呢？

A：一般是有两种应用场景，一种场景是有些小的币种要求销毁一定数量的比特币才能够得到这个币种。有时候这种小币种叫alt coin（alternative coin），除了比特币之外的其他小的加密货币。要用这种方法证明付出了一定的代价才能够得到这个小币种。另外一个应用场景是往区块链里写入一些内容。因为区块链是个不可篡改的账本，那么可以利用这个特性往里面添加一些需要永久保存量内容。比如涉及到知识产权保护的，把某项知识产权的内容取哈希之后，把哈希值放在这个 return 语句的后面，最后面的内容反正是永远不会执行的，你往里写什么都没关系。而且你放在这里的是一个哈希值，你有什么知识产权取个哈希之后，把哈希值放在这个不会占太大的地方，而且也没有泄露出来你知识产权的具体内容。

coinbase transaction 里面有一个 coinbase 域，在这个域里写什么内容同样是没人管的。如果要使用这种方法来记录某些不能改变的内容只有获得记账权的那个节点才能用。而在输出脚本的 return 后面添加内容的方法是所有的节点都可以用的，甚至不一定是个节点，可能就是一个普通的比特币上的用户，任何人都可以用这种方法去写入一些内容。

任何用户都可以用这种方法销毁很少一点比特币来换取往这个区块链里面写入一些内容的机会。另外，有些交易其实根本就没有销毁比特币，只不过支付了交易费。比如执行的交易的输入是 0.05 个比特币，输出金额是0，说明输入金额全部用来支付交易费了。这个交易其实并没有销毁任何比特币，只不过把数里的比特币作为交易费转给这个挖到矿的矿工了。（付款人写交易脚本）

这种形式的脚本的一个好处是旷工看到这种脚本的时候，知道它里面的输出永远不可能兑现，所以就没有必要把它保存在 utxo 里面，这样对全节点是比较友好的。

比特币系统当中用的这个脚本语言是非常简单的，甚至连专门的名字都没有，就叫比特币脚本语言 bitcoin scripting  language ，像以太坊当中用的智能合约的语言，这就比这个要复杂得多。比如说比特币的脚本语言不支持循环，所以有很多功能这个语言是实现不了的，这样的设计是有其用意的，不支持循环就不会有死循环，不用担心停机问题。像以太坊当中，它的智能合约的语言是图灵完备的，表达能力很强，所以就要需要靠汽油费的机制来防止这个程序陷入死循环。另外一方面，我们注意这个语言虽然在某些方面功能是很有限的，但是在另外一些方面它的功能却很强大，比如说和密码学相关的功能是很强大的。比如说这个检查多重签名，用一条语句就能够完成，这个比很多通用的编程语言要方便的多。所以比特币的脚本语言虽然看上去很简单，但其实针对比特币的应用场景做了很好的优化。



# 9. BTC-分叉

分叉是原来是一条链，现在分成了两条链，这就叫做分叉。

可能是多种原因造成的：

- 挖矿的时候，如果有两个节点差不多同一个时候挖到了矿，那么这个时候两个节点都可以发布区块，这时候就会出现一个临时性的分叉，这样的分叉叫做 state fork（由于对比特币当前的状态有意见分歧而导致的分叉）。
- 分叉攻击（Forking attack）也属于 state fork，只不过这个意见分歧是故意人为造成的，所以也叫做 deliberate fork。 

- 比特币的协议发生了改变。要修改比特币协议需要软件升级。在一个去中心化的系统里，升级软件的时候没有办法保证所有的节点同时都升级软件。假设大部分节点升级了软件，少数节点因为种种原因可能没有升级，那么这个时候也会出现分差。这种分差叫 protocol fork。根据对协议修改的内容的不同，可以进一步分成叫硬分叉和软分叉。



## hard fork

出现硬分叉的情况：

如果对这个比特币协议增加一些新的特性 new feature 扩展一些新的功能，这个时候那些没有升级软件的节点是不认可这些新特性的，认为这些特性是非法的。这个时候就属于对比特币协议的内容产生了意见分析，就会导致分叉。硬分叉的一个例子就是比特币中的区块大小限制。

比特币规定每个区块最多是 1 兆字节。那么有些人认为太小了，影响了增加了交易的延迟。（1 兆是 100 万字节，一个交易差不多认为是 250 个字节，那么一个区块最多对应 4000 个交易左右，产生一个区块的时间平均是 10 分钟，也就是大概是每秒钟 7 笔交易）

假设有人发布一个软件更新，把这个 block side limit 从 1 兆增加到 4 兆。

假设大多数节点更新的软件把 block size limit 更新到 4 兆，少数节点没有更新（大多数节点和少数节点不是按照账户数目来算的，而是按照算力来算）

![image-20221108032452786](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108032452786.png)

更新软件之后有一个新节点挖出一个区块，这个区块比较大，这个区块旧节点是不认可的，所以它不会从这个区块往下继续挖，还会沿着这个原来的区块链继续挖。旧节点挖出来的区块新节点是认可的，因为规定区块大小不能超过 4 兆，比 4 兆小是可以的，所以旧节点挖的链是新旧节点都认可的。

因为假设大多数节点是更新软件的，所以大多数新节点是认可新节点挖到的区块，会沿着继续挖，只有少数旧结点不认可。新节点认为上下两条链都是合法的，但上面这个是最长合法链，所以新节点会继续沿着这条链挖，而且它算力因为足够多，会使这个链变得越来越长。但对旧节点看来下面的链才是合法的，上面这个链无论有多长都是没用的，因为那是非法的链，所以你这个挖的多长，它都不会沿着这个挖，它会沿着下面这个挖。这个分叉是永久性的，只要这部分旧节点不更新软件，这个分叉就不会消失。

Q：出现 hard folk 之后，分叉中的区块得到的出块奖励还有没有用？

A：出现 hard fork 之后就变成了两条平行运行的链，彼此之间有各自的这个加密货币。各自的币在各自的链上是认的。

Q：在分叉之前的币怎么办？

A：分叉之前的币按道理说应该变成上下两条链都认可，一个币应该是拆成两个。以太坊有一个经典的例子：以太坊叫 etherum ETH ，现在看到的 ETH 已经不是当初的 ETH 了，而是经过分叉了。受到攻击之后，当初的开发者决定用硬分叉的方法重新记账，把这个黑客偷到的钱退回给当初的投资者，分叉完之后有个叫 etc 的 isram classic 这个实际上才是真正原来的协议。但就是有人不同意这样做，产生了分叉。在分叉之前获得的币在分叉之后的两个链上都可以花，但是真正分叉完之后，如果不采取一些措施的话，这两条链互相之间会有一定影响：ETH 跟 ETC 分叉完之后，因为原来是一条链，账户私钥都是一样的。在分裂完之后，如果不采取任何措施的话，就会出现两条链上别的都一样，就是运行的协议不一样，就会导致获取双倍的币。所以后来就加一个措施，这两条链各带一个 chain ID  把它给分开了。现在的以太坊都是两条独立运行的链了。

## soft fork

出现软分叉的情况：

比如对比特币协议一些限制，假设有人发布一个软件更新，把这个区块大小变小了，从 1 兆变成了 0.5 兆。在分叉之后，新节点开始挖不超过半兆的小区块，这个区块对旧节点来说是认同的，但是旧节点挖出的大区块新节点是不认的。此时根据新协议挖出的区块新旧节点都是认同的，但是旧节点挖出的区块只有旧节点认同。

因为旧节点如果不更新软件的话，挖出的区块可能就白挖了，所以这个分叉是临时性的。

实际当中可能出现软分差的情况：

- 给某些目前协议中没有规定的域增加一些新的含义，赋予一些新的规则。例如区块中的 coinbase 域（每个发布的区块里可以有一个铸币交易 coinbase transaction，其中有一个域为 coinbase。挖矿的时候要不断的调 block header 里的 nonce ，但 block header 的 nonce 只有 4 个字节，最多是 2 的 32 次方的可能性，搜索空间不够大。所以实际当中，可以把这 coinbase 前 8 个字节也要用来做 extra nonce， 这就变成了 2 的 96 次方，作为目前的挖矿难度已经是足够了，但是这个 coinbase 不止是八个字节，它后面还有好多），除了前八位作为 extra nonce 来挖矿之外，剩下的字节有人提出作为 utxo 集合（当前还没有花掉的交易的输出）的根哈希值。目前只是每个全节点在这个内存中维护这样一个集合，主要是为了快速查找能够判断这个交易是不是 double spending 。但是这个集合的内容并没有写到区块链里。要证明某个账户上有多少钱，这个目前在比特币系统当中是证明不出来的。如果是全节点的话，这个你可以算一下 utxo 里对应的某个账户的输出中一共有多少个币。但是对于一个轻节点来说，要知道账户的余额需要询问其他的全节点，全节点返回一个结果，轻节点如何验证正确性，所以提议把 utxo 集合当中的内容也组织成一棵 merkle tree，对应有一个根哈希值，这个根哈希写在 coinbase 域中。集合的根哈希在这个域中的内容最终往上传递的时候会传递到 block header 的根哈希值，更改 utxo 的内容，最终会导致 block header 的根哈希值跟着改。这样轻节点就可以用 merkle  proof 验证全节点返回内容的正确性。这是个软分叉。因为新节点发布的区块，旧节点认为是合法的。

- 比特币历史上一个比较著名的软分叉的例子是 pay to script hash。这个功能在最初的比特币版本里是没有的，后来通过软分叉的方法给加进去。支付的时候不是付给一个 public key 的哈希，而是付给一个赎回脚本的哈希 redeem script。花钱的时候，要把这个交易的输入脚本跟前面币的来源的交易的输出脚本拼在一起执行。执行的时候，验证分为两步，第一步是要验证输入脚本中给出的这个 redeem script 跟前面输出脚本给出的这个 script 的哈希值是对得上的，证明这个输入脚本你提供这个 script 是正确的。第二部分再去验证执行这个 redeem script 来验证输入脚本里给出的这些签名是合法的，就完成了两阶段的验证。对于旧节点来说，只会做第一阶段的验证，新节点才会做第二阶段的验证。所以旧节点认为合法的交易，新节点可能认为是非法的。

可能有一些临时性的分叉

总结：

soft fork 的特点是只要系统中拥有半数以上算力的节点更新了软件，可能有一些临时性的分叉，但是这个系统就不会出现永久性的分叉。

hard fork 的特点是所有的节点都要更新软件，系统才不会出现永久性的分叉。如果有小部分节点不愿意更新，那么这个系统就会分成两条链。



# 10. BTC-问答




Q：如果转账交易的时候接收者不在线怎么办？

A：不需要接收者在线转账交易，只不过是在区块链上要记录一下，把某个账户上的比特币转到其他的账户上，是不是当时连在比特币网络是没有关系的。



Q：某个全节点有没有可能收到了一个接收者的收款地址是该节点以前从来没有听说过的转账交易？

A：是可能的，比特币账户在创建的时候是不需要通知其他人的，在本地产生一个公私钥对就可以了。只有在该收款地址第一次收到钱的时候，其他节点才知道这个账户的存在。



Q：如果账户的私钥丢失了该怎么办？

A：私钥丢失之后是没有办法的，该账户上的钱就变成了死钱，永远取不出来了。这个和平时的生活体验不太一样。银行的账户密码丢了，可以去银行查验一下身份，然后进行重置密码。在去中心化的系统里是没有人可以重置密码的。

有些加密货币的交易所，一般来说这些交易所是中心化的机构。那么在交易所开办一个账户的时候，一般来说是要提供身份证明的。如果要在某个加密货币的交易所有自己的账户，那么就类似于银行开户一样，一般也是要经过身份验证。这种情况下你把你的比特币保存在交易所里，那么私钥实际上是由交易所来保管的。登录这个交易所的话，是和登录银行差不多的程序，有一个账户名，有一个密码，一般来说还需要二次验证然后登录。这种情况下，如果账户密码丢失了，可以去跟交易所联系。通过身份验证之后重置密码。

有一些在线群包也提供这个保管私钥的功能。并不是说交易所或者是在线钱包比自己保管私钥更安全。比特币的的交易所或者说加密货币的交易所目前处于一种缺乏监管的状态，这个和股票交易所是很不一样的。历史上曾经发生过很多次加密货币的交易所被黑的情况，黑客从里面偷走了大量的这种加密货币。其中最著名的一个例子，门头沟的例子。曾经是全世界最大的一个比特币交易所，交易量占到了全球比特币交易量的70%。它是设在日本的，后来被黑客攻击了，丢失了大量的比特币。这个交易所后来破产了，CEO 被判刑了。而且这个不是个例。各种加密货币交易所出现问题的情况发生过很多次，也有的是交易所坚守自盗，

相比之下，有些冷钱包或者是硬件钱包是比较安全的。



Q：如果私钥泄露了怎么办？

A：应该尽快的把账上的钱转到另外一个的安全账户上。这个也跟平时的生活体验不太一样。如果银行账户上出现一些可疑的交易，可能首先想到的是通知银行能够怎能不能怎么把密码重置了，然后把账户冻结，免得别人把钱取走。但是这些在区块链的世界里都是做不到的。比特币这个账户所谓的密码是它产生账户的时候生成的公钥和私钥对，这个公私钥对一旦生成之后是没有办法改的，也没有办法再改成另外一个私钥。同样的，也没有办法阻止别人发布从这个账户上转账的交易。任何有私钥的人都可以发布一个转账交易，把这个账户账的钱转走，这个也是没有办法冻结的。能做的只能是在第一时间抢在别人之前，把自己账户上钱转到一个安全的账户上。



Q：如果转账的时候写错了地址该怎么办？

A：没有办法取消已经发布的交易。比特币当中转账交易一旦发布到区块链上，就没有办法取消了，没有提供这种机制来取消某个已经发布的交易。如果知道是谁的地址的话，可以跟对方联系一下，看看他愿不愿意把这个钱还给你，但是没有办法强迫。如果不知道是谁的地址或者转的是一个不存在的地址，那就没有办法。



Q：什么叫不存在的地址？

A：地址是公钥的哈希得到的。但是有些地址其实不是公钥的哈希得到的。而是是用哈希生成一个看上去像比特币地址的东西，这个地址是没有对应的私钥，其实是个假的地址。



Q：如何把某些内容的哈希值发布到区块链上，证明曾经在某个时间知道某个事情。

A：一种比较经典的做法是把要发布的哈希值放在交易的 OP_RETURN 后面，这是推荐采用的方法。

或者是用哈希生成一个看上去像比特币地址的东西，这个地址是没有对应的私钥，其实是个假的地址。这种做法牺牲一点比特币，换取往区块链里写入这个哈希值的一个机会，这个做法是不提倡的。因为这个转账交易的输出会永久的保存在 utxo 里面。全节点收到这样一个转账交易，并不知道这个地址是真的还是假的，不知道这个钱其实是花不出去的，所以必须永久的把它保存起来，对全节点是不友好的。



Q：Proof  of  Burn 实际当中是怎么操作的？这个语句是无条件的要返回错误，那么怎么可能被写到区块链里呢？

A：验证的时候是是把当前这个交易的输入脚本跟前面交易币的来源的交易的输出脚本拼在一起看能不能顺利执行，这个执行过程中是不可以抛出错误的，如果抛出错误就不是合法交易。Proof  of  Burn 这是写在当前交易的输出脚本里的，所以验证当前这个交易合法性的时候不会执行这个语句。要花这个币的时候交易的输出的才会执行。



Q：会不会有的矿工偷答案？把其他节点找到的 nonce 作为自己找到的 nonce 发布出去？

A：发布的区块里有一个 coinbase transaction，里面有一个收款人地址，是这个挖到矿的矿工的地址。如果修改了该地址，就会导致这个区块的 merkle tree 的根哈希值会变化。block header 的内容发生了变化之后，原来找到的 nonce 就作废了，所以不可能偷答案



Q：怎么知道交易费该给哪个矿工？事先怎么知道哪个矿工会挖到矿？

A：事先不需要知道哪个矿工会得到这个交易费，交易费是怎么算的？只要 total input 大于 total output 这个差额就是交易费。发布的一个交易可以有很多个输入，也可以有很多个输出，总输入减去总输出，差额就是交易费。可以把区块里所包含的交易的这些差额都收集起来作为交易费。



比特币上面的一些统计数据：

比特币区块链的大小的变化情况：

![image-20221108213427226](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108213427226.png)

区块链是越来越大的， size 不断增大。只能往里面添东西，区块链的长度越来越长，它的 size 就越来越大。目前这个 size 对于当前硬盘的容量来说还是完全没有问题的，区块链的大部分内容是可以保存在硬盘上的，这个是



utxo 集合的大小：

![image-20221108213532940](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108213532940.png)

集合总的趋势是不断变大的，有一些波动。主要原因就是比特币交易多了之后， utxo 的集合会跟着一起变大。另一方面是历史原因造成的，有一些账户可能是私钥丢失了，所以这些账户对应的这些输出在 utxo 里就要永久的保存下去。时间长了之后，这种情况累积下来也会变多一点。



比特币矿池挖矿的情况：

![image-20221108213746582](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221109200122241.png)

挖矿集中化的趋势也是很严重 mining centralization。几个大的矿池占了系统中总算力的很大一部分。



比特币的交易量

![image-20221108213951768](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108213746582.png)

波动非常大。这个交易量是按照美元价格算出来的交易量。所以这个波动当中有一部分是比特币本身的价格波动造成。



每个区块的交易数量：

![image-20221108214051819](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108213951768.png)

因为难度调整算法要把出块时间稳定在 10 分钟，所以每天产生的区块数目是差不多的。交易数目的变化主要就是因为每个区块里所包含的交易数目发生的变化。每个区块按照 1 兆的字节来算的话，差不多 4000 个交易。现在这个情况是远远没有达到这个上限，所以有很多人说这个 1M 的上限太小了。真实的区块链实际上很多区块是没有装满的。





# BTC-匿名性

一般来说，匿名 anonymity 是跟隐私 privacy 保护联系在一起的。

比特币中不要求用真名，可以用公钥产生的地址。从这一点上来说，它有一定的匿名性，但是不是说完全没有名字，使用的是化名 pseudonymity。

比特币中的匿名它不是一种真的匿名，就好像网上发帖子使用的网名。

比特币这个区块链的账本是公开的，所有人都能查的。比特币是完全公开的



## 破坏匿名性的情况

- 交易的不同的输入和输出地址是可以被关联在一起的。比如网上购物比特币交易允许有多个输入和多个输出，因为某个人同时控制了两个账户的私钥，所以某个交易的 input 可能有两个账户。因为要买的那个东西一般很难恰好是某一个账户的全部的值，有一个很可能是找零钱的地址，所以 output 也可以有两个。一个交易可能会有多个输入，也会有多个输出。假设有一个这样的交易发布到了区块链上，可以认为输出的地址都是属于同一个人的。虽然比特币生成交易的时候并没有规定找零钱的地址在 output 当中出现的位置，但是在某些情况下，可以通过输出的金额分析出来，所以可以把输入地址跟输出地址也关联起来。

  ![image-20221109200122241](http://rk90puzbu.hb-bkt.clouddn.com/blog_imgs/image-20221108214051819.png)

  Q：此时如何获得隐私保护？

  A：可以人为的产生一些没必要的输出，故意生成某些不必要的输出地址。这种交易一般都是比特币钱包软件生成的，每次交易的时候会自动生成一个新的找零的地址，现在很少有人手动生成这些比特币的转账交易。但是常用的比特币钱包就那么几种，如果把常用的比特币钱包生成交易的方式搞清楚，那么区块链上很大一部分转账交易都可以分析出来。常用的钱包到目前为止一般没有故意生成不必要的输出地址。

- 地址账户和社会现实世界中的真实身份可能产生关联。如果只是在区块链内部玩，跟实体世界从来不发生任何联系，这个是没有问题的，一旦跟实体世界发生联系，涉及到资金的转入和转出时就可能泄露真实身份。当使用资金购买比特币的时候，就会有一个资金转入区块链的过程。可以去交易所买，那么在交易所登记注册的时候一般是要有身份信息。另外也可以有场外交易（私下交易），直接交易的人也会泄露身份。

  Q：怎么防范用比特币进行洗钱的违法行为？

  A：盯住资金的转入转出链是一个常用的手段。如果有特别大的资金要转入到比特币里面，或者有很多的比特币想转成法币，想要不引起司法部门的注意实际是很难的。资金的转入转出也是比特币隐私有可能被破坏的一个很重要的时机。

  另外，用比特币做支付（弊端：延迟很大，交易费很贵）的时候。收比特币的时候就会引起隐私泄露，用于支付的账户和真实身份是建立联系的，这个账户可能和其他账户之间也是有联系的，所以合在一起就很容易把这个人的很多情况都给摸清楚。

  这个其实不光是接受支付的商家会知道，其他人其实也会知道。比特币的交易记录都是公开的。在区块链查在对应的时间产生的交易，很快就能知道账户和现实世界的人的对应关系，这也是破坏匿名性的一种方法。



比特币的匿名性并不是绝对的，没有想象中的那么好。实际当中过去的经验表明，凡是用比特币从事违法活动，最后都能被抓起来。

中本聪能够那么长期的保持匿名性，实际上是属于个例，就并不是一个常态。

比特币的匿名性有多好？匿名是跟隐私保护相关联的，这个问题在于不想向谁暴露身份。hide your identity from whom?



## 提高匿名性的方法

比特币协议实际上是运行在应用层的。底层是是个 P2P 的 overly network 。所以要提高匿名性，要从两个方面入手。

- 网络层：

区块链是个新生事物，但是网络层的匿名性已经有了很好的解决方案。比较普遍的就是用多路径转发的方法。

消息不是由 sender 直接发给 receiver， 而是中间要经过很多跳，application 的 level 要经过很多次转发，中间的每一个节点只知道它的上一个节点是谁，但是并不知道最早发出这个消息的人是谁。

当然中间这些节点当中有一些可能是坏的，但是只要是这个路径上有一个节点是诚实的，就能够把这个最初发件人的身份给隐藏起来。

- 应用层：

因为区块链是个公开的账本，花的每一个币都可以追溯到它的源头。同一个人的各个不同的比特币账户之间会被关联起来。

要起到匿名保护的作用。一种做法就是把各个不同的人的币混在一起 coin mixing。其实不光是区块链，在其他所有的领域需要达到匿名性的领域，把身份跟周围的人混在一起都是个常用的做法。

首先，有一些专门做 coin mixing 的网站，提供这种服务收取一定的服务费。把币发给这些网站，它内部进行一些重组，然后再把取回来，此时取回来的币一般来说就不是当初发到这个网站上的币了。真正实施起来有一定的复杂性。如果设计不好的话，可能有一些 set channel 有一些 traffic analysis ，根据当初存进去币的数额能够推断出来哪些币实际上是存进去的。但是现在在这个区块链世界里没有什么信誉度非常高的 call mixing 的服务。call mixing 的服务它本身也是要保持匿名的，如果投进去的这些币被卷款跑路了，实际上是一点办法都没有的。

另外，不一定要特意的去做 call a mixing。某些钱包应用本身带有 call a mixing 的性质。但是在线钱包并不保证要履行 call mixing 的功能。其他的，加密货币的交易所一般来说有一种天然的 call a mixing 的性质。前提是交易所不会泄露相关的提币存币的记录

因为区块链是公开且不可篡改的，导致保护隐私性难度挺大。



## 零知识证明

是指证明者向验证者证明一个陈述是正确的，而无需透露除了该陈述是正确的之外的任何信息。

例如证明某一个比特币账户是我的，要向你证明我知道私钥，可以产生一个用这个私钥进行的签名，假设你是知道这个账户的公钥的，那么你可以验证一下这个签名的正确性。



## 同态隐藏

零知识证明的数学基础是同态隐藏。

三个性质：

- 如果  x, y  不同, 那么它们的加密函数值  E(x)  和  E(y)  也不相同。加密函数值 E 不会出现碰撞。
- 给定  E(x)  的值，很难反推出  x  的值。加密函数是不可逆的。
- 同态运算，给定  E(x)  和  E(y)  的值, 我们可以很容易地计算出某 些关于  x, y  的加密函数值。加密之后的函数值进行某些代数运算，等价于对这些输入直接进行代数运算然后再加密。
  - 同态加法，加密值的就等于和的加密，或者说它不一定非要相等，它可以通过这种和的加密能够算出来。
  - 同态乘法，在加密后的函数值的乘积等于乘积之后再加密。

## 盲签

不知道具体内容的情况下，对内容进行签名。

为了保护用户的隐私，避免账户之间的关联。



## 零币和零钞

比特币在一定程度上提供了匿名性，但是它不能够完全消除关联性。

从一开始的体系结构设计上就用了密码学的原理，保证匿名性。零币和零钞专门为了匿名性设计的加密货币。

零币存在一种基础币 base coin 比如说比特币，还有零币 zerocoin。用的时候要证明本来是有一个基础币的，把这个基础币搞的是不能花了 unspandable，然后换取一个零币。零币在花的时候只需要证明用零知识证明，证明花掉的币是这个区块链上某个合法存在的币就行了，把这些关联性给破坏掉，不用透露花的具体是系统中的哪一个币。

零钞只有 zerocoin。

这个是跟比特币的一个本质区别，比特币的每一笔转账交易都要说明币的来源，交易中花掉的币是过去的哪个交易中产生的，这样才能够保证你花掉的币的真实性不是凭空捏造出来的。

这些专门为匿名性设计的新的加密货币到现在也不是很主流。

- 这些加密货币为了匿名性是付出一定代价的，在性能上是有一定的损失的。
- 对数学原理上、对初始化有比较严格的要求，初始的时候用的随机源要能够销毁掉，如果没有很好的销毁掉的话，那么会有一定的安全漏洞。
- 可能需要强匿名性的用户本来也不是很多。
- 并不一定是就是 100% 匿名安全。与实体世界发生交互的时候，仍然要暴露身份。数学上设计的再好，只是说在区块链当中进行转账等等有匿名性。



# BTC-思考

## 哈希指针

比特币系统在设计当中很多地方用到了哈希指针，比如区块的块头包含指向前一个区块的哈希指针。

实际上，所谓的哈希指针只是一种形象的说法，实际系统中用的时候只有哈希没有指针。block header 里面只有哈希值，没有指针。全节点一般是把区块存储在一个 k，,value 数据库里面，key 是区块的哈希，value 是区块的内容。一个常用的 k，value 数据库是 level DB。

区块链这种链表结构实际上是在 level DB 里面用哈希值来串起来的。只要掌握了最后一个区块的哈希值，那么在 level DB 里查找哈希值，key 对应的 value 就可以把最后一个区块的内容取出来。然后这个区块里面 header 里面中指向前一个区块的哈希值，那么再去查找 key 和 value 可以找到前一个区块的内容。以此类推，一步一步往前找，最终能够把整个区块链都找出来。

有一些节点没有保存完整的区块链的信息，只保存了最近的几千个区块。如果需要用到前面的区块的信息，可以问其他的全节点要希指针，保证了整个区块链的内容是不可篡改的。



## “区块恋”

两个人合在一起买比特币，把私钥从中间截断分成两部分，每人保留其中的一段。将来如果两个人继续好下去的话，那么两段四要合在一起就能够把钱取出来。如果两个人分手了，那么当初买的币就被永久的锁在区块链上，谁也取不出来。

存在的问题：

- 当中任何一个人如果把私钥丢了，这个钱都取不出来了。
- 截断私钥的做法会降低账户的安全性。比特币系统当中每个账户的安全性跟所用的私钥的长度是相关的。私钥为 256 位，这个长度的私钥用暴力破解的方法是不可行的。截断后破解的可能性指数性降低。
- 忘记私钥，账户的币会永久保存在 utxo 中，对全节点不友好。

对于多个人的共享账户，不要用截断私钥的方法。可以使用多重签名 multi sig，多重签名当中用到的每一个私钥都是独立产生的，而不是说把一个大的私钥拆成好几段。而且多重签名还提供一些灵活性，要求 N 个人当中任意给出 M 个人签名就可以了。



## 分布式共识

从理论上证明分布式系统当中取得共识是不可能的。

严格的说，比特币并没有取得真正意义下的共识，因为取得的共识随时都有可能被推翻。比如出现了分叉攻击，系统会回滚到前一个状态，从理论上说甚至可能一直回滚到创世纪块。按照分布式系统理论的要求，共识一旦达成之后就不应该再改了。所以从这个意义上说，比特币并没有绕过分布式系统那些不可能的结论。

理论和实际往往是有距离的。很多理论上不可能结论对于实际当中是并不适用的。



## 比特币的稀缺性

要想吸引大家来挖矿，要么增加这个挖矿的预期收益，要么降低挖矿的开销。

任何一种新发行的这种加密货币都有一个能启动的问题，早期的时候你这个加密货币不是很流行，可以给早期的矿工更多的收益，

比特币一方面早期的挖矿难度比较低，很容易就可以挖到。另一方面早期的出块奖励也是比较高的，每个区块是 50 个，比特币现在就降到了 12.5 个，然后越往后还会越来越少。

其实这种总量固定的东西是不适合用来作为货币的。社会财富越来越多了，都集中在这个少量的货币上，会变得越来越值钱。

但是通货膨胀不一定是一件坏事，因为货币价值的上涨使得个人奋斗变得没有意义了。一个健康向上的社会是不应该出现这种情况。



## 量子计算

量子计算机是非常强大的，可以破解各种现有的加密式算法。

担心是不必要的：

- 量子计算技术离实用还有很长一段距离，实际上量子计算离实用还差得很远，在比特币的有生之年不一定能够产生实质性的威胁。
- 如果将来有一天量子计算真正强大到能够破坏现有的加密体系的话。那么首先冲击的是传统金融业。

- 比特币当中并没有把账户的公钥直接暴露出来，而是用公钥取哈希之后得到一个地址。比特币当中用的非对称加密体系，从私钥是可以推导出公钥的，但是从公钥当中显然是不能推出私钥的。这是比特币加密算法的一个特点。所以只要把私钥保管好，公钥即使丢了也没有关系。

加密和取哈希是两个不同性质的操作。加密的目的是为了将来能够解密，所以加密算法要保证信息的完整性，加密过程是不能够丢失信息的，这样将来解密的时候才能够还原出原来的输入。但是取哈希的过程一般来说是会造成信息的损失的，哈希函数一般都是不可逆的，从这个哈希值没有办法推导出原来的输入是什么，因为有很多信息在取哈希的过程中就已经丢失了。

比特币系统当中，如果仅仅是为了收钱，收款没必要把公钥暴露出来，只暴露一个公钥的哈希生成了地址就行了。

将来要取钱的时候才需要提供公钥，取钱的那个交易里面得有公钥，还要有一个私钥产生的一个签名，从安全性的角度来看，比特币的一个地址一旦用过之后就不要再用了。从这个地址取钱的时候，最好是一次性的把里面所有的钱都取走。

